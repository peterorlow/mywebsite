<!DOCTYPE html>
<html>
<head>
    <title>Maze Shooter - No Map, Unlimited Ammo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', monospace;
        }
        canvas {
            display: block;
            image-rendering: pixelated;
            width: 800px;
            height: 600px;
        }
        #ui {
            position: absolute;
            color: white;
            font-family: monospace;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #8B0000;
            border-radius: 5px;
            bottom: 20px;
            left: 20px;
        }
        #startScreen {
            position: absolute;
            color: white;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 3px solid #8B0000;
            border-radius: 10px;
            text-align: center;
            max-width: 400px;
        }
        button {
            background-color: #8B0000;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 10px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            cursor: pointer;
        }
        button:hover {
            background-color: #A00000;
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>MAZE SHOOTER</h1>
        <p>Find the exit to complete the maze!</p>
        <p>WASD: Move | Arrows: Look | SPACE: Shoot</p>
        <button id="startButton">START GAME</button>
    </div>
    <canvas id="gameCanvas" style="display:none"></canvas>
    <div id="ui" style="display:none">
        HEALTH: 100 | AMMO: ∞ | SCORE: 00000
    </div>

    <script>
        // Game constants
        const CELL_SIZE = 64;
        const FOV = Math.PI / 3; // 60 degrees
        const HALF_FOV = FOV / 2;
        const NUM_RAYS = 320;
        const MAX_DEPTH = 20;
        const WALK_SPEED = 3;
        const ROT_SPEED = 0.05;
        const MAZE_SIZE = 15; // 15x15 maze
        const NUM_ENEMIES = 5;
        const SHOTS_TO_KILL = 3;

        // Game canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 800;
        canvas.height = 600;

        // Game state
        let map = [];
        let exitPosition = { x: 0, y: 0 };
        let gameStarted = false;
        let enemies = [];
        let bullets = [];

        // Player position and angle
        const player = {
            x: CELL_SIZE * 1.5,
            y: CELL_SIZE * 1.5,
            angle: Math.PI / 4,
            health: 100,
            score: 0
        };

        // Keyboard state
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            ArrowLeft: false,
            ArrowRight: false,
            space: false
        };

        // Texture data - generated procedurally
        const textureSize = 64;
        let textureData = null;
        let enemyTexture = null;
        let bulletTexture = null;

        // Generate procedural brick texture
        function generateBrickTexture() {
            const textureCanvas = document.createElement('canvas');
            textureCanvas.width = textureSize;
            textureCanvas.height = textureSize;
            const textureCtx = textureCanvas.getContext('2d');
            
            // Brick color
            textureCtx.fillStyle = '#8B0000';
            textureCtx.fillRect(0, 0, textureSize, textureSize);
            
            // Draw brick pattern
            textureCtx.fillStyle = '#A52A2A';
            for (let y = 0; y < textureSize; y += 8) {
                for (let x = 0; x < textureSize; x += 16) {
                    textureCtx.fillRect(x + (y % 16 === 0 ? 0 : 8), y, 14, 6);
                }
            }
            
            // Add some noise for texture
            const imageData = textureCtx.getImageData(0, 0, textureSize, textureSize);
            for (let i = 0; i < imageData.data.length; i += 4) {
                // Add slight color variation
                imageData.data[i] += Math.floor(Math.random() * 10) - 5;   // R
                imageData.data[i+1] += Math.floor(Math.random() * 10) - 5; // G
                imageData.data[i+2] += Math.floor(Math.random() * 10) - 5; // B
            }
            textureCtx.putImageData(imageData, 0, 0);
            
            return textureCtx.getImageData(0, 0, textureSize, textureSize).data;
        }

        // Generate enemy texture
        function generateEnemyTexture() {
            const textureCanvas = document.createElement('canvas');
            textureCanvas.width = textureSize;
            textureCanvas.height = textureSize;
            const textureCtx = textureCanvas.getContext('2d');
            
            // Enemy body
            textureCtx.fillStyle = '#FF0000';
            textureCtx.beginPath();
            textureCtx.arc(textureSize/2, textureSize/2, textureSize/2 - 5, 0, Math.PI * 2);
            textureCtx.fill();
            
            // Enemy eyes
            textureCtx.fillStyle = '#FFFFFF';
            textureCtx.beginPath();
            textureCtx.arc(textureSize/2 - 10, textureSize/2 - 5, 5, 0, Math.PI * 2);
            textureCtx.arc(textureSize/2 + 10, textureSize/2 - 5, 5, 0, Math.PI * 2);
            textureCtx.fill();
            
            textureCtx.fillStyle = '#000000';
            textureCtx.beginPath();
            textureCtx.arc(textureSize/2 - 10, textureSize/2 - 5, 2, 0, Math.PI * 2);
            textureCtx.arc(textureSize/2 + 10, textureSize/2 - 5, 2, 0, Math.PI * 2);
            textureCtx.fill();
            
            return textureCtx.getImageData(0, 0, textureSize, textureSize).data;
        }

        // Generate bullet texture
        function generateBulletTexture() {
            const textureCanvas = document.createElement('canvas');
            textureCanvas.width = textureSize;
            textureCanvas.height = textureSize;
            const textureCtx = textureCanvas.getContext('2d');
            
            // Bullet shape
            textureCtx.fillStyle = '#FFD700';
            textureCtx.beginPath();
            textureCtx.arc(textureSize/2, textureSize/2, textureSize/4, 0, Math.PI * 2);
            textureCtx.fill();
            
            // Add shine
            textureCtx.fillStyle = '#FFFFFF';
            textureCtx.beginPath();
            textureCtx.arc(textureSize/2 + 5, textureSize/2 - 5, 3, 0, Math.PI * 2);
            textureCtx.fill();
            
            return textureCtx.getImageData(0, 0, textureSize, textureSize).data;
        }

        // Initialize game
        function initGame() {
            // Reset keyboard state to prevent auto-walking
            for (let key in keys) {
                keys[key] = false;
            }
            
            // Generate textures
            textureData = generateBrickTexture();
            enemyTexture = generateEnemyTexture();
            bulletTexture = generateBulletTexture();
            
            // Reset game state
            enemies = [];
            bullets = [];
            player.health = 100;
            player.score = 0;
            
            generateMaze();
            placePlayerInMaze();
            spawnEnemies();
            gameStarted = true;
            
            // Show game elements
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('ui').style.display = 'block';
            
            // Start game loop
            gameLoop();
        }

        // Spawn enemies in the maze
        function spawnEnemies() {
            for (let i = 0; i < NUM_ENEMIES; i++) {
                let x, y;
                do {
                    x = 1 + Math.floor(Math.random() * (MAZE_SIZE - 2));
                    y = 1 + Math.floor(Math.random() * (MAZE_SIZE - 2));
                } while (map[y][x] !== 0 || 
                       Math.abs(x - Math.floor(player.x / CELL_SIZE)) < 3 ||
                       Math.abs(y - Math.floor(player.y / CELL_SIZE)) < 3);
                
                enemies.push({
                    x: (x + 0.5) * CELL_SIZE,
                    y: (y + 0.5) * CELL_SIZE,
                    health: SHOTS_TO_KILL,
                    angle: Math.random() * Math.PI * 2,
                    speed: 0.5 + Math.random() * 0.5
                });
            }
        }

        // Generate a random maze with guaranteed path to exit
        function generateMaze() {
            // Initialize filled maze with borders
            map = Array(MAZE_SIZE).fill().map(() => Array(MAZE_SIZE).fill(1));
            
            // Start from a random cell
            const startX = 1 + Math.floor(Math.random() * (MAZE_SIZE - 2));
            const startY = 1 + Math.floor(Math.random() * (MAZE_SIZE - 2));
            
            // Create a stack for DFS and visited cells
            const stack = [[startX, startY]];
            const visited = Array(MAZE_SIZE).fill().map(() => Array(MAZE_SIZE).fill(false));
            visited[startY][startX] = true;
            map[startY][startX] = 0;
            
            // Directions: up, right, down, left
            const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            
            while (stack.length > 0) {
                const [x, y] = stack[stack.length - 1];
                const shuffledDirections = directions.sort(() => Math.random() - 0.5);
                
                let moved = false;
                
                for (const [dx, dy] of shuffledDirections) {
                    const nx = x + dx * 2; // Move 2 cells to carve paths
                    const ny = y + dy * 2;
                    
                    if (nx > 0 && nx < MAZE_SIZE - 1 && ny > 0 && ny < MAZE_SIZE - 1 && !visited[ny][nx]) {
                        // Carve path
                        map[y + dy][x + dx] = 0;
                        map[ny][nx] = 0;
                        visited[ny][nx] = true;
                        stack.push([nx, ny]);
                        moved = true;
                        break;
                    }
                }
                
                if (!moved) {
                    stack.pop();
                }
            }
            
            // Place exit at the farthest point from start with guaranteed path
            exitPosition = findFarthestPoint(startX, startY);
            map[exitPosition.y][exitPosition.x] = 2;
            
            // Ensure there's always a path by verifying with pathfinding
            ensurePathToExit(startX, startY);
        }

        // Find farthest point from start for exit placement
        function findFarthestPoint(startX, startY) {
            let maxDist = 0;
            let farthest = { x: startX, y: startY };
            const visited = Array(MAZE_SIZE).fill().map(() => Array(MAZE_SIZE).fill(false));
            const queue = [[startX, startY, 0]];
            visited[startY][startX] = true;
            
            while (queue.length > 0) {
                const [x, y, dist] = queue.shift();
                
                if (dist > maxDist && map[y][x] === 0) {
                    maxDist = dist;
                    farthest = { x, y };
                }
                
                // Check neighbors
                const neighbors = [[0, -1], [1, 0], [0, 1], [-1, 0]];
                for (const [dx, dy] of neighbors) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < MAZE_SIZE && ny >= 0 && ny < MAZE_SIZE && 
                        !visited[ny][nx] && map[ny][nx] !== 1) {
                        visited[ny][nx] = true;
                        queue.push([nx, ny, dist + 1]);
                    }
                }
            }
            
            return farthest;
        }

        // Ensure there's a path from start to exit by removing blocking walls
        function ensurePathToExit(startX, startY) {
            const path = findPath(startX, startY, exitPosition.x, exitPosition.y);
            if (!path) {
                // If no path exists, remove walls along the straight line path
                const dx = exitPosition.x - startX;
                const dy = exitPosition.y - startY;
                const steps = Math.max(Math.abs(dx), Math.abs(dy));
                
                for (let i = 0; i <= steps; i++) {
                    const x = Math.floor(startX + (dx * i) / steps);
                    const y = Math.floor(startY + (dy * i) / steps);
                    if (map[y][x] === 1) {
                        map[y][x] = 0;
                    }
                    // Also clear adjacent cells to ensure walkable path
                    if (x > 0 && map[y][x-1] === 1) map[y][x-1] = 0;
                    if (x < MAZE_SIZE-1 && map[y][x+1] === 1) map[y][x+1] = 0;
                    if (y > 0 && map[y-1][x] === 1) map[y-1][x] = 0;
                    if (y < MAZE_SIZE-1 && map[y+1][x] === 1) map[y+1][x] = 0;
                }
            }
        }

        // A* pathfinding algorithm to verify path exists
        function findPath(startX, startY, targetX, targetY) {
            const openSet = [{x: startX, y: startY, g: 0, h: heuristic(startX, startY, targetX, targetY)}];
            openSet[0].f = openSet[0].g + openSet[0].h;
            const closedSet = new Set();
            const cameFrom = {};
            const gScore = Array(MAZE_SIZE).fill().map(() => Array(MAZE_SIZE).fill(Infinity));
            gScore[startY][startX] = 0;
            
            while (openSet.length > 0) {
                openSet.sort((a, b) => a.f - b.f);
                const current = openSet.shift();
                
                if (current.x === targetX && current.y === targetY) {
                    // Reconstruct path
                    const path = [];
                    let node = current;
                    while (node) {
                        path.push(node);
                        node = cameFrom[`${node.x},${node.y}`];
                    }
                    return path.reverse();
                }
                
                closedSet.add(`${current.x},${current.y}`);
                
                const neighbors = [[0, -1], [1, 0], [0, 1], [-1, 0]];
                for (const [dx, dy] of neighbors) {
                    const nx = current.x + dx;
                    const ny = current.y + dy;
                    
                    if (nx < 0 || nx >= MAZE_SIZE || ny < 0 || ny >= MAZE_SIZE || 
                        map[ny][nx] === 1 || closedSet.has(`${nx},${ny}`)) {
                        continue;
                    }
                    
                    const tentativeG = gScore[current.y][current.x] + 1;
                    if (tentativeG < gScore[ny][nx]) {
                        cameFrom[`${nx},${ny}`] = current;
                        gScore[ny][nx] = tentativeG;
                        const h = heuristic(nx, ny, targetX, targetY);
                        const f = tentativeG + h;
                        
                        const existing = openSet.find(n => n.x === nx && n.y === ny);
                        if (!existing) {
                            openSet.push({x: nx, y: ny, g: tentativeG, h, f});
                        } else {
                            existing.g = tentativeG;
                            existing.h = h;
                            existing.f = f;
                        }
                    }
                }
            }
            
            return null; // No path found
        }

        // Heuristic function for A*
        function heuristic(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) + Math.abs(y1 - y2); // Manhattan distance
        }

        // Place player in a valid starting position
        function placePlayerInMaze() {
            // Find a position with guaranteed path to exit
            let startX, startY;
            do {
                startX = 1 + Math.floor(Math.random() * (MAZE_SIZE - 2));
                startY = 1 + Math.floor(Math.random() * (MAZE_SIZE - 2));
            } while (map[startY][startX] !== 0 || 
                   !findPath(startX, startY, exitPosition.x, exitPosition.y) ||
                   (Math.abs(startX - exitPosition.x) < 5 && 
                    Math.abs(startY - exitPosition.y) < 5));
            
            player.x = (startX + 0.5) * CELL_SIZE;
            player.y = (startY + 0.5) * CELL_SIZE;
            player.angle = Math.random() * Math.PI * 2;
        }

        // Event listeners for keyboard
        document.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key)) keys[e.key] = true;
            if (e.key === ' ') keys.space = true;
        });

        document.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) keys[e.key] = false;
            if (e.key === ' ') keys.space = false;
        });

        // Start button
        document.getElementById('startButton').addEventListener('click', initGame);

        // Get pixel from procedural texture
        function getTexturePixel(x, y, texture) {
            x = Math.max(0, Math.min(textureSize - 1, Math.floor(x)));
            y = Math.max(0, Math.min(textureSize - 1, Math.floor(y)));
            
            const i = (y * textureSize + x) * 4;
            return {
                r: texture[i],
                g: texture[i + 1],
                b: texture[i + 2],
                a: texture[i + 3]
            };
        }

        // Game loop
        function gameLoop() {
            if (!gameStarted) return;
            
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Update game state
        function update() {
            // Player movement
            const moveX = Math.cos(player.angle) * WALK_SPEED;
            const moveY = Math.sin(player.angle) * WALK_SPEED;

            if (keys.w) {
                const newX = player.x + moveX;
                const newY = player.y + moveY;
                if (!isWall(newX, newY)) {
                    player.x = newX;
                    player.y = newY;
                }
            }
            if (keys.s) {
                const newX = player.x - moveX;
                const newY = player.y - moveY;
                if (!isWall(newX, newY)) {
                    player.x = newX;
                    player.y = newY;
                }
            }
            if (keys.a) {
                const strafeX = Math.cos(player.angle - Math.PI/2) * WALK_SPEED;
                const strafeY = Math.sin(player.angle - Math.PI/2) * WALK_SPEED;
                const newX = player.x + strafeX;
                const newY = player.y + strafeY;
                if (!isWall(newX, newY)) {
                    player.x = newX;
                    player.y = newY;
                }
            }
            if (keys.d) {
                const strafeX = Math.cos(player.angle + Math.PI/2) * WALK_SPEED;
                const strafeY = Math.sin(player.angle + Math.PI/2) * WALK_SPEED;
                const newX = player.x + strafeX;
                const newY = player.y + strafeY;
                if (!isWall(newX, newY)) {
                    player.x = newX;
                    player.y = newY;
                }
            }
            if (keys.ArrowLeft) player.angle -= ROT_SPEED;
            if (keys.ArrowRight) player.angle += ROT_SPEED;
            if (keys.space) shoot();
            
            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].x += bullets[i].dx;
                bullets[i].y += bullets[i].dy;
                
                // Remove bullets that hit walls or go out of bounds
                if (isWall(bullets[i].x, bullets[i].y) || 
                    bullets[i].x < 0 || bullets[i].x > MAZE_SIZE * CELL_SIZE ||
                    bullets[i].y < 0 || bullets[i].y > MAZE_SIZE * CELL_SIZE) {
                    bullets.splice(i, 1);
                    continue;
                }
                
                // Check for bullet-enemy collisions
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const dist = Math.sqrt(
                        Math.pow(bullets[i].x - enemies[j].x, 2) + 
                        Math.pow(bullets[i].y - enemies[j].y, 2)
                    );
                    
                    if (dist < CELL_SIZE / 2) {
                        enemies[j].health--;
                        player.score += 10;
                        bullets.splice(i, 1);
                        
                        if (enemies[j].health <= 0) {
                            player.score += 50;
                            enemies.splice(j, 1);
                        }
                        break;
                    }
                }
            }
            
            // Update enemies
            for (let i = 0; i < enemies.length; i++) {
                // Simple AI: move toward player
                const dx = player.x - enemies[i].x;
                const dy = player.y - enemies[i].y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    const moveX = (dx / dist) * enemies[i].speed;
                    const moveY = (dy / dist) * enemies[i].speed;
                    
                    if (!isWall(enemies[i].x + moveX, enemies[i].y + moveY)) {
                        enemies[i].x += moveX;
                        enemies[i].y += moveY;
                    }
                    
                    enemies[i].angle = Math.atan2(dy, dx);
                }
                
                // Check for enemy-player collision
                if (dist < CELL_SIZE / 2) {
                    player.health -= 0.5;
                    if (player.health <= 0) {
                        alert(`GAME OVER! Final Score: ${player.score}`);
                        initGame();
                        return;
                    }
                }
            }
            
            // Check if player reached exit
            const exitCellX = Math.floor(player.x / CELL_SIZE);
            const exitCellY = Math.floor(player.y / CELL_SIZE);
            if (exitCellX >= 0 && exitCellX < MAZE_SIZE && 
                exitCellY >= 0 && exitCellY < MAZE_SIZE && 
                map[exitCellY][exitCellX] === 2) {
                player.score += 1000;
                alert(`MAZE COMPLETED! Final Score: ${player.score}`);
                initGame(); // Start new maze
            }
            
            // Update UI
            document.getElementById('ui').innerHTML = 
                `HEALTH: ${Math.floor(player.health)} | AMMO: ∞ | SCORE: ${player.score.toString().padStart(5, '0')}`;
        }

        // Check if position is a wall
        function isWall(x, y) {
            const cellX = Math.floor(x / CELL_SIZE);
            const cellY = Math.floor(y / CELL_SIZE);
            
            if (cellX < 0 || cellX >= MAZE_SIZE || cellY < 0 || cellY >= MAZE_SIZE) {
                return true; // Out of bounds counts as wall
            }
            
            return map[cellY][cellX] === 1;
        }

        // Shooting function
        function shoot() {
            // Unlimited ammo - no ammo check
            
            // Add bullet
            bullets.push({
                x: player.x,
                y: player.y,
                dx: Math.cos(player.angle) * 10,
                dy: Math.sin(player.angle) * 10,
                lifetime: 100
            });
            
            // Simple shooting effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.fillRect(canvas.width/2 - 2, canvas.height/2 - 20, 4, 40);
            setTimeout(() => {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.fillRect(canvas.width/2 - 1, canvas.height/2 - 10, 2, 20);
            }, 50);
        }

        // Render the game
        function render() {
            // Clear screen
            ctx.fillStyle = '#112';
            ctx.fillRect(0, 0, canvas.width, canvas.height/2);
            
            // Draw floor (darker gradient)
            const floorGradient = ctx.createLinearGradient(0, canvas.height/2, 0, canvas.height);
            floorGradient.addColorStop(0, '#222');
            floorGradient.addColorStop(1, '#111');
            ctx.fillStyle = floorGradient;
            ctx.fillRect(0, canvas.height/2, canvas.width, canvas.height/2);
            
            // Only render if game started
            if (!gameStarted) return;
            
            // Raycasting
            for (let col = 0; col < NUM_RAYS; col++) {
                // Calculate ray angle
                const rayAngle = player.angle - HALF_FOV + (col / NUM_RAYS) * FOV;
                
                // Cast ray
                let rayX = player.x;
                let rayY = player.y;
                let rayCos = Math.cos(rayAngle);
                let raySin = Math.sin(rayAngle);
                
                let wall = 0;
                let distance = 0;
                let wallX, wallY;
                let verticalHit = false;
                let exitHit = false;
                
                // DDA (Digital Differential Analysis) algorithm
                let mapX = Math.floor(rayX / CELL_SIZE);
                let mapY = Math.floor(rayY / CELL_SIZE);
                
                let deltaDistX = Math.abs(1 / rayCos);
                let deltaDistY = Math.abs(1 / raySin);
                
                let stepX, stepY;
                let sideDistX, sideDistY;
                
                if (rayCos < 0) {
                    stepX = -1;
                    sideDistX = (rayX / CELL_SIZE - mapX) * deltaDistX;
                } else {
                    stepX = 1;
                    sideDistX = (mapX + 1.0 - rayX / CELL_SIZE) * deltaDistX;
                }
                
                if (raySin < 0) {
                    stepY = -1;
                    sideDistY = (rayY / CELL_SIZE - mapY) * deltaDistY;
                } else {
                    stepY = 1;
                    sideDistY = (mapY + 1.0 - rayY / CELL_SIZE) * deltaDistY;
                }
                
                // Perform DDA
                while (wall === 0 && distance < MAX_DEPTH * CELL_SIZE) {
                    if (sideDistX < sideDistY) {
                        sideDistX += deltaDistX;
                        mapX += stepX;
                        verticalHit = false;
                    } else {
                        sideDistY += deltaDistY;
                        mapY += stepY;
                        verticalHit = true;
                    }
                    
                    // Check if ray hit a wall or exit
                    if (mapX >= 0 && mapX < MAZE_SIZE && mapY >= 0 && mapY < MAZE_SIZE) {
                        wall = map[mapY][mapX];
                        if (wall === 2) exitHit = true;
                    } else {
                        wall = 1;
                    }
                    
                    distance += 1;
                }
                
                // Calculate distance (correct for fish-eye effect)
                let perpWallDist;
                if (!verticalHit) {
                    perpWallDist = (mapX - rayX / CELL_SIZE + (1 - stepX) / 2) / rayCos;
                } else {
                    perpWallDist = (mapY - rayY / CELL_SIZE + (1 - stepY) / 2) / raySin;
                }
                
                // Calculate wall height
                const lineHeight = Math.floor(canvas.height / perpWallDist);
                
                // Calculate texture coordinates
                let wallXHit;
                if (!verticalHit) {
                    wallXHit = rayY / CELL_SIZE + perpWallDist * raySin;
                } else {
                    wallXHit = rayX / CELL_SIZE + perpWallDist * rayCos;
                }
                wallXHit -= Math.floor(wallXHit);
                
                let texX = Math.floor(wallXHit * textureSize);
                if ((!verticalHit && rayCos > 0) || (verticalHit && raySin < 0)) {
                    texX = textureSize - texX - 1;
                }
                
                // Draw wall slice
                const drawStart = Math.max(0, Math.floor(-lineHeight / 2 + canvas.height / 2));
                const drawEnd = Math.min(canvas.height, Math.floor(lineHeight / 2 + canvas.height / 2));
                const columnWidth = (canvas.width / NUM_RAYS) + 1;
                const columnX = col * (canvas.width / NUM_RAYS);
                
                // Draw textured wall column
                if (exitHit) {
                    // Draw exit door (green)
                    for (let y = drawStart; y < drawEnd; y++) {
                        const shade = 1.0 - Math.min(1.0, perpWallDist / (CELL_SIZE * 8));
                        const r = Math.floor(0 * shade);
                        const g = Math.floor(200 * shade);
                        const b = Math.floor(0 * shade);
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(columnX, y, columnWidth, 1);
                    }
                } else if (wall === 1) {
                    // Draw brick wall
                    for (let y = drawStart; y < drawEnd; y++) {
                        const texY = Math.floor((y - canvas.height / 2 + lineHeight / 2) * textureSize / lineHeight);
                        const pixel = getTexturePixel(texX, texY, textureData);
                        
                        // Apply distance shading
                        const shade = 1.0 - Math.min(1.0, perpWallDist / (CELL_SIZE * 8));
                        const r = Math.floor(pixel.r * shade);
                        const g = Math.floor(pixel.g * shade);
                        const b = Math.floor(pixel.b * shade);
                        
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(columnX, y, columnWidth, 1);
                    }
                }
            }
            
            // Draw enemies
            for (const enemy of enemies) {
                const relX = enemy.x - player.x;
                const relY = enemy.y - player.y;
                const enemyDist = Math.sqrt(relX * relX + relY * relY);
                const angle = Math.atan2(relY, relX) - player.angle;

                let normalizedAngle = angle;
                while (normalizedAngle > Math.PI) normalizedAngle -= 2 * Math.PI;
                while (normalizedAngle < -Math.PI) normalizedAngle += 2 * Math.PI;

                if (Math.abs(normalizedAngle) < HALF_FOV) {
                    const rayX = player.x;
                    const rayY = player.y;
                    const dx = enemy.x - rayX;
                    const dy = enemy.y - rayY;
                    const distToEnemy = Math.sqrt(dx * dx + dy * dy);

                    const step = 4;
                    let visible = true;
                    for (let d = 0; d < distToEnemy; d += step) {
                        const testX = rayX + Math.cos(player.angle + normalizedAngle) * d;
                        const testY = rayY + Math.sin(player.angle + normalizedAngle) * d;
                        if (isWall(testX, testY)) {
                            visible = false;
                            break;
                        }
                    }

                    if (visible) {
                        const screenX = (normalizedAngle + HALF_FOV) / FOV * canvas.width;
                        const size = CELL_SIZE / enemyDist * 300;

                        for (let y = 0; y < size; y++) {
                            const texY = Math.floor(y / size * textureSize);
                            for (let x = 0; x < size; x++) {
                                const texX = Math.floor(x / size * textureSize);
                                const pixel = getTexturePixel(texX, texY, enemyTexture);

                                if (pixel.a > 0) {
                                    const shade = 1.0 - Math.min(1.0, enemyDist / (CELL_SIZE * 8));
                                    const r = Math.floor(pixel.r * shade);
                                    const g = Math.floor(pixel.g * shade);
                                    const b = Math.floor(pixel.b * shade);

                                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                                    ctx.fillRect(
                                        screenX - size / 2 + x,
                                        canvas.height / 2 - size / 2 + y,
                                        1, 1
                                    );
                                }
                            }
                        }
                    }
                }
            }
            
            // Draw bullets
            for (const bullet of bullets) {
                // Calculate bullet position relative to player
                const relX = bullet.x - player.x;
                const relY = bullet.y - player.y;
                
                // Calculate distance and angle to bullet
                const dist = Math.sqrt(relX * relX + relY * relY);
                const angle = Math.atan2(relY, relX) - player.angle;
                
                // Normalize angle to be between -PI and PI
                let normalizedAngle = angle;
                while (normalizedAngle > Math.PI) normalizedAngle -= 2 * Math.PI;
                while (normalizedAngle < -Math.PI) normalizedAngle += 2 * Math.PI;
                
                // Only draw if bullet is in field of view
                if (Math.abs(normalizedAngle) < HALF_FOV) {
                    // Calculate screen position
                    const screenX = (normalizedAngle + HALF_FOV) / FOV * canvas.width;
                    const size = 10 / dist * 300;
                    
                    // Draw bullet sprite
                    for (let y = 0; y < size; y++) {
                        const texY = Math.floor(y / size * textureSize);
                        for (let x = 0; x < size; x++) {
                            const texX = Math.floor(x / size * textureSize);
                            const pixel = getTexturePixel(texX, texY, bulletTexture);
                            
                            if (pixel.a > 0) { // Only draw non-transparent pixels
                                const r = Math.floor(pixel.r);
                                const g = Math.floor(pixel.g);
                                const b = Math.floor(pixel.b);
                                
                                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                                ctx.fillRect(
                                    screenX - size/2 + x, 
                                    canvas.height/2 - size/2 + y, 
                                    1, 1
                                );
                            }
                        }
                    }
                }
            }
            
            // Draw weapon
            ctx.fillStyle = 'rgba(100, 100, 100, 0.7)';
            ctx.fillRect(canvas.width / 2 - 25, canvas.height - 80, 50, 60);
            ctx.fillStyle = 'rgba(70, 70, 70, 0.9)';
            ctx.fillRect(canvas.width / 2 - 20, canvas.height - 60, 40, 40);
            
            // Draw crosshair
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.fillRect(canvas.width/2 - 2, canvas.height/2 - 10, 4, 4);
            ctx.fillRect(canvas.width/2 - 10, canvas.height/2 - 2, 4, 4);
            ctx.fillRect(canvas.width/2 + 6, canvas.height/2 - 2, 4, 4);
        }
    </script>
</body>
</html>
